#!/bin/bash
# Script to demonstrate Docker build cache efficiency with multi-stage builds

echo "=== Docker Build Cache Efficiency Demo ==="
echo ""
echo "The multi-stage Dockerfile provides several benefits:"
echo ""
echo "1. ğŸš€ FASTER BUILDS: Dependencies are cached separately from application code"
echo "   - When you change code, only the final COPY . . step rebuilds"
echo "   - Dependencies (poetry export + pip install) stay cached"
echo ""
echo "2. ğŸ“¦ SMALLER IMAGES: No poetry or build tools in final image"
echo "   - Only runtime dependencies are included"
echo "   - Cleaner, more secure production images"
echo ""
echo "3. ğŸ”’ REPRODUCIBLE BUILDS: Poetry lock ensures exact dependency versions"
echo "   - poetry.lock file pins all transitive dependencies"
echo "   - Same versions across all environments"
echo ""
echo "4. ğŸ—ï¸ BETTER CACHING: Multi-stage approach optimizes Docker layer caching"
echo "   - Dependencies layer rarely changes"
echo "   - Application code changes don't invalidate dependency cache"
echo ""
echo "Current setup:"
echo "- Poetry version: 1.8.3"
echo "- Dagster version: 1.8.1"
echo "- All dependencies pinned via poetry.lock"
echo ""
echo "To see the benefits, try:"
echo "1. Make a small code change"
echo "2. Run 'docker-compose build'"
echo "3. Notice how only the final layers rebuild!"
